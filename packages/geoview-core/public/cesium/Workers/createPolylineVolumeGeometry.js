/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.128
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as W}from"./chunk-OX3IVXYD.js";import{a as U}from"./chunk-HJB4AZ37.js";import"./chunk-NSW7N5NB.js";import"./chunk-56SXHQAK.js";import{a as x,b as I,c as j}from"./chunk-GKEVDBS4.js";import"./chunk-GL6V53IR.js";import"./chunk-T4QMV5NY.js";import{a as g}from"./chunk-YPLJFYMF.js";import"./chunk-D7EBM725.js";import"./chunk-6HLC35BP.js";import{a as $,b as M}from"./chunk-XUAV2AYX.js";import{a as Z}from"./chunk-FLU3S7Y5.js";import"./chunk-FT22QKWD.js";import"./chunk-HGNPNJ5T.js";import"./chunk-ISZ7WW7L.js";import{a as X}from"./chunk-CF754CSJ.js";import{a as Q}from"./chunk-CZ3TUBLX.js";import{b as V,c as Y,d as B}from"./chunk-L4Y3PGRA.js";import{d as K}from"./chunk-BHOMZQKL.js";import"./chunk-O23FQWOY.js";import{a as N}from"./chunk-KGIGJVHC.js";import{a as E,c as D,d as f,f as J}from"./chunk-V3YO6LNK.js";import{a as H}from"./chunk-XAJAI4KM.js";import"./chunk-QJ75BJDL.js";import"./chunk-SAZKQEJR.js";import{a as A}from"./chunk-Y5QCE4LD.js";import{e as _}from"./chunk-V7XFDMXL.js";function oe(e,t,n,o){let r=new Q;o.position&&(r.position=new B({componentDatatype:N.DOUBLE,componentsPerAttribute:3,values:e}));let i,a,s,p,c,l,u=t.length,h=e.length/3,m=(h-2*u)/(2*u),g=M.triangulate(t),f=(m-1)*u*6+2*g.length,k=X.createTypedArray(h,f),d=2*u,y=0;for(i=0;i<m-1;i++){for(a=0;a<u-1;a++)s=2*a+i*u*2,l=s+d,p=s+1,c=p+d,k[y++]=p,k[y++]=s,k[y++]=c,k[y++]=c,k[y++]=s,k[y++]=l;s=2*u-2+i*u*2,p=s+1,c=p+d,l=s+d,k[y++]=p,k[y++]=s,k[y++]=c,k[y++]=c,k[y++]=s,k[y++]=l}if(o.st||o.tangent||o.bitangent){let e,o,s=new Float32Array(2*h),p=1/(m-1),c=1/n.height,l=n.height/2,g=0;for(i=0;i<m;i++){for(e=i*p,o=c*(t[0].y+l),s[g++]=e,s[g++]=o,a=1;a<u;a++)o=c*(t[a].y+l),s[g++]=e,s[g++]=o,s[g++]=e,s[g++]=o;o=c*(t[0].y+l),s[g++]=e,s[g++]=o}for(a=0;a<u;a++)e=0,o=c*(t[a].y+l),s[g++]=e,s[g++]=o;for(a=0;a<u;a++)e=(m-1)*p,o=c*(t[a].y+l),s[g++]=e,s[g++]=o;r.st=new B({componentDatatype:N.FLOAT,componentsPerAttribute:2,values:new Float32Array(s)})}let _=h-2*u;for(i=0;i<g.length;i+=3){let e=g[i]+_,t=g[i+1]+_,n=g[i+2]+_;k[y++]=e,k[y++]=t,k[y++]=n,k[y++]=n+u,k[y++]=t+u,k[y++]=e+u}let v=new Y({attributes:r,indices:k,boundingSphere:K.fromVertices(e),primitiveType:V.TRIANGLES});if(o.normal&&(v=U.computeNormal(v)),o.tangent||o.bitangent){try{v=U.computeTangentAndBitangent(v)}catch{I("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}o.tangent||(v.attributes.tangent=void 0),o.bitangent||(v.attributes.bitangent=void 0),o.st||(v.attributes.st=void 0)}return v}function v(e){let t=(e=e??J.EMPTY_OBJECT).polylinePositions,n=e.shapePositions;if(!_(t))throw new A("options.polylinePositions is required.");if(!_(n))throw new A("options.shapePositions is required.");this._positions=t,this._shape=n,this._ellipsoid=f.clone(e.ellipsoid??f.default),this._cornerType=e.cornerType??x.ROUNDED,this._vertexFormat=g.clone(e.vertexFormat??g.DEFAULT),this._granularity=e.granularity??H.RADIANS_PER_DEGREE,this._workerName="createPolylineVolumeGeometry";let o=1+t.length*E.packedLength;o+=1+n.length*D.packedLength,this.packedLength=o+f.packedLength+g.packedLength+2}v.pack=function(e,t,n){if(!_(e))throw new A("value is required");if(!_(t))throw new A("array is required");n=n??0;let o,r=e._positions,i=r.length;for(t[n++]=i,o=0;o<i;++o,n+=E.packedLength)E.pack(r[o],t,n);let a=e._shape;for(i=a.length,t[n++]=i,o=0;o<i;++o,n+=D.packedLength)D.pack(a[o],t,n);return f.pack(e._ellipsoid,t,n),n+=f.packedLength,g.pack(e._vertexFormat,t,n),n+=g.packedLength,t[n++]=e._cornerType,t[n]=e._granularity,t};var ee=f.clone(f.UNIT_SPHERE),te=new g,S={polylinePositions:void 0,shapePositions:void 0,ellipsoid:ee,vertexFormat:te,cornerType:void 0,granularity:void 0};v.unpack=function(e,t,n){if(!_(e))throw new A("array is required");t=t??0;let o,r=e[t++],i=new Array(r);for(o=0;o<r;++o,t+=E.packedLength)i[o]=E.unpack(e,t);r=e[t++];let a=new Array(r);for(o=0;o<r;++o,t+=D.packedLength)a[o]=D.unpack(e,t);let s=f.unpack(e,t,ee);t+=f.packedLength;let p=g.unpack(e,t,te);t+=g.packedLength;let c=e[t++],l=e[t];return _(n)?(n._positions=i,n._shape=a,n._ellipsoid=f.clone(s,n._ellipsoid),n._vertexFormat=g.clone(p,n._vertexFormat),n._cornerType=c,n._granularity=l,n):(S.polylinePositions=i,S.shapePositions=a,S.cornerType=c,S.granularity=l,new v(S))};var ne=new W;v.createGeometry=function(e){let t=e._positions,n=Z(t,E.equalsEpsilon),o=e._shape;if(o=j.removeDuplicatesFromShape(o),n.length<2||o.length<3)return;M.computeWindingOrder2D(o)===$.CLOCKWISE&&o.reverse();let r=W.fromPoints(o,ne);return oe(j.computePositions(n,o,r,e,!0),o,r,e._vertexFormat)};var z=v;function ie(e,t){return _(t)&&(e=z.unpack(e,t)),e._ellipsoid=f.clone(e._ellipsoid),z.createGeometry(e)}var Re=ie;export{Re as default};