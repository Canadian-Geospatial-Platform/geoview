/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.128
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as R}from"./chunk-H5ORMCZ2.js";import{a as It}from"./chunk-REC7BNVA.js";import{a as M}from"./chunk-HHFCN56M.js";import{a as bt}from"./chunk-NSW7N5NB.js";import"./chunk-D7EBM725.js";import"./chunk-6HLC35BP.js";import"./chunk-HGNPNJ5T.js";import"./chunk-ISZ7WW7L.js";import{a as W}from"./chunk-CF754CSJ.js";import"./chunk-BHOMZQKL.js";import{h as z}from"./chunk-O23FQWOY.js";import"./chunk-KGIGJVHC.js";import{a as o,b as nt,d as j}from"./chunk-V3YO6LNK.js";import{a as et}from"./chunk-XAJAI4KM.js";import"./chunk-QJ75BJDL.js";import"./chunk-SAZKQEJR.js";import"./chunk-Y5QCE4LD.js";import{e as A}from"./chunk-V7XFDMXL.js";var kt=new o,Bt=new j,Nt=new z,E={min:void 0,max:void 0,indexBytesPerElement:void 0};function Pt(t){let e=new Float64Array(t),n=0;E.indexBytesPerElement=e[n++],E.min=e[n++],E.max=e[n++],o.unpack(e,n,kt),n+=o.packedLength,j.unpack(e,n,Bt),n+=j.packedLength,z.unpack(e,n,Nt)}function Tt(t){let e=t.length,n=0;for(let r=0;r<e;++r)n+=R.packedLength+3+t[r].batchIds.length;return n}function Ct(t,e,n){let r=e.length,a=2+r*M.packedLength+1+Tt(n),o=new Float64Array(a),i=0;o[i++]=t,o[i++]=r;for(let t=0;t<r;++t)M.pack(e[t],o,i),i+=M.packedLength;let s=n.length;o[i++]=s;for(let t=0;t<s;++t){let e=n[t];R.pack(e.color,o,i),i+=R.packedLength,o[i++]=e.offset,o[i++]=e.count;let r=e.batchIds,a=r.length;o[i++]=a;for(let t=0;t<a;++t)o[i++]=r[t]}return o}var yt=32767,wt=new o,Ht=new o,St=new o,Ut=new o,Ft=new o,Lt=new nt,Mt=new z;function Rt(t,e){let n;Pt(t.packedBuffer),n=2===E.indexBytesPerElement?new Uint16Array(t.indices):new Uint32Array(t.indices);let r=new Uint16Array(t.positions),a=new Uint32Array(t.counts),i=new Uint32Array(t.indexCounts),s=new Uint32Array(t.batchIds),f=new Uint32Array(t.batchTableColors),l=new Array(a.length),c=kt,h=Bt,u=Nt,m=E.min,p=E.max,d=t.minimumHeights,g=t.maximumHeights;A(d)&&A(g)&&(d=new Float32Array(d),g=new Float32Array(g));let k,w,I,b=r.length/2,y=r.subarray(0,b),N=r.subarray(b,2*b);bt.zigZagDeltaDecode(y,N);let L=new Float64Array(3*b);for(k=0;k<b;++k){let t=y[k],e=N[k],n=et.lerp(u.west,u.east,t/yt),r=et.lerp(u.south,u.north,e/yt),a=nt.fromRadians(n,r,0,Lt),i=h.cartographicToCartesian(a,wt);o.pack(i,L,3*k)}let x=a.length,j=new Array(x),T=new Array(x),B=0,F=0;for(k=0;k<x;++k)j[k]=B,T[k]=F,B+=a[k],F+=i[k];let O=new Float32Array(3*b*2),S=new Uint16Array(2*b),C=new Uint32Array(T.length),U=new Uint32Array(i.length),H=[],P={};for(k=0;k<x;++k)I=f[k],A(P[I])?(P[I].positionLength+=a[k],P[I].indexLength+=i[k],P[I].batchIds.push(k)):P[I]={positionLength:a[k],indexLength:i[k],offset:0,indexOffset:0,batchIds:[k]};let J,D=0,G=0;for(I in P)if(P.hasOwnProperty(I)){J=P[I],J.offset=D,J.indexOffset=G;let t=2*J.positionLength,e=2*J.indexLength+6*J.positionLength;D+=t,G+=e,J.indexLength=e}let V=[];for(I in P)P.hasOwnProperty(I)&&(J=P[I],V.push({color:R.fromRgba(parseInt(I)),offset:J.indexOffset,count:J.indexLength,batchIds:J.batchIds}));for(k=0;k<x;++k){I=f[k],J=P[I];let t=J.offset,e=3*t,r=t,b=j[k],y=a[k],N=s[k],E=m,x=p;A(d)&&A(g)&&(E=d[k],x=g[k]);let B=Number.POSITIVE_INFINITY,F=Number.NEGATIVE_INFINITY,R=Number.POSITIVE_INFINITY,D=Number.NEGATIVE_INFINITY;for(w=0;w<y;++w){let t=o.unpack(L,3*b+3*w,wt);h.scaleToGeodeticSurface(t,t);let n=h.cartesianToCartographic(t,Lt),a=n.latitude,i=n.longitude;B=Math.min(a,B),F=Math.max(a,F),R=Math.min(i,R),D=Math.max(i,D);let s=h.geodeticSurfaceNormal(t,Ht),f=o.multiplyByScalar(s,E,St),l=o.add(t,f,Ut);f=o.multiplyByScalar(s,x,f);let u=o.add(t,f,Ft);o.subtract(u,c,u),o.subtract(l,c,l),o.pack(u,O,e),o.pack(l,O,e+3),S[r]=N,S[r+1]=N,e+=6,r+=2}u=Mt,u.west=R,u.east=D,u.south=B,u.north=F,l[k]=M.fromRectangle(u,m,p,h);let G=J.indexOffset,V=T[k],W=i[k];for(C[k]=G,w=0;w<W;w+=3){let e=n[V+w]-b,r=n[V+w+1]-b,a=n[V+w+2]-b;H[G++]=2*e+t,H[G++]=2*r+t,H[G++]=2*a+t,H[G++]=2*a+1+t,H[G++]=2*r+1+t,H[G++]=2*e+1+t}for(w=0;w<y;++w){let e=w,n=(w+1)%y;H[G++]=2*e+1+t,H[G++]=2*n+t,H[G++]=2*e+t,H[G++]=2*e+1+t,H[G++]=2*n+1+t,H[G++]=2*n+t}J.offset+=2*y,J.indexOffset=G,U[k]=G-C[k]}H=W.createTypedArray(O.length/3,H);let Y=V.length;for(let t=0;t<Y;++t){let e=V[t].batchIds,n=0,r=e.length;for(let t=0;t<r;++t)n+=U[e[t]];V[t].count=n}let _=Ct(2===H.BYTES_PER_ELEMENT?W.UNSIGNED_SHORT:W.UNSIGNED_INT,l,V);return e.push(O.buffer,H.buffer,C.buffer,U.buffer,S.buffer,_.buffer),{positions:O.buffer,indices:H.buffer,indexOffsets:C.buffer,indexCounts:U.buffer,batchIds:S.buffer,packedBuffer:_.buffer}}var Jt=It(Rt);export{Jt as default};