<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sandbox Configuration - Canadian Geospatial Platform Viewer</title>
  <link rel="shortcut icon" href="./favicon.ico" />
  <meta name="msapplication-TileColor" content="#da532c" />
  <meta name="msapplication-config" content="./img/browserconfig.xml" />
  <meta name="theme-color" content="#ffffff" />
  <meta name="msapplication-TileColor" content="#da532c" />
  <meta name="theme-color" content="#ffffff" />
  <link rel="stylesheet" href="css/style.css" />

  <!-- codeql-disable Security/HtmlInclusionOfUntrustedContent -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/liquibyte.css"/>
  <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"></script>
  <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/perl/perl.min.js"></script>
  <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/xml/xml.min.js"></script>
  <script language="javascript" type="text/javascript" src="https://cdn.jsdelivr.net/npm/@codemirror/matchbrackets@0.19.4/+esm"></script>
  <!-- codeql-enable Security/HtmlInclusionOfUntrustedContent -->

  <style>
    .section {
      margin: 5px;
    }
    .select {
      padding: 2px;
    }
    .text-input {
      width: 90%;
      padding: 2px;
    }
    .text-info {
      color: blue;
      font-size: smaller;
    }
    .text-error {
      color: red;
    }
    .CodeMirror {
      height: 700px; /* Height of the text area */
    }
    .result {
      position: relative;
    }
    .loading-overlay {
      display: none;
      position: absolute;
      z-index: 1;
    }
    .loading-overlay img {
      width: 100px;
    }
  </style>
</head>

<body>
  <div>
    <div id="page-header"></div>

    <div class="back-to-main">
      <a href="./index.html?tab=sandbox">← Back to Main</a>
    </div>

    <div class="demo-section">
      <h4>Configuration Sandbox</h4>
      <p>
        Test the ConfigApi with different layer types and configurations. Initialize layers from URLs and process their configurations to see the generated layer metadata.
      </p>
    </div>
    <div class="demo-section">
      <h4>Layer Configuration</h4>
      <div class="section sandbox-option-flex">
        <div class="navigator-option-group">
          <label for="language" class="navigator-label">Language:</label>
          <select id="language" class="select navigator-select">
            <option value="en">English</option>
            <option value="fr">French</option>
          </select>
        </div>
        <div>
          <label for="urls" class="navigator-label">Layer type:</label>
          <select id="urls" class="select navigator-select-full"></select>
        </div>
      </div>
      <div class="section navigator-option-group">
        <label for="txtUrl" class="navigator-label">URL:</label>
        <input id="txtUrl" type="text" class="text-input sandbox-input-full" />
      </div>
      <div id="section-layer-id" class="section sandbox-section-spacing" style="display: none">
        <label for="txtLayerId" class="sandbox-label-block">Layer ID:</label>
        <input id="txtLayerId" type="text" class="text-input sandbox-input-full" />
      </div>
      <div class="section sandbox-section-spacing">
        <button id="btnInitialize" type="button" class="btn btn-primary">Initialize</button>
      </div>
      <div class="section sandbox-info-box">
        <p id="txtProcessInfoVector" class="sandbox-info-text">
          <strong>ℹ️ Note:</strong> When working with a vector layer, some source information is only retrieved when the layer is actually added on a map, as to not download the features twice (once in the config processing and once when the layer is added to a map).
        </p>
      </div>
      <div class="section sandbox-min-height">
        <span id="txtError" class="text-error sandbox-error-text"></span>
      </div>
      <div class="section result sandbox-section-spacing">
        <div id="loadingOverlayInit" class="loading-overlay"><img src="https://discuss.wxpython.org/uploads/default/original/2X/6/6d0ec30d8b8f77ab999f765edd8866e8a97d59a3.gif" /></div>
        <textarea id="textResultInit" name="textResultInit" class="sandbox-textarea"></textarea>
      </div>
    </div>

    <div class="demo-section">
      <h4>Process Layers</h4>
      <div class="section sandbox-section-spacing">
        <label for="txtLayers" class="sandbox-label-block">Layers:</label>
        <input id="txtLayers" type="text" class="text-input sandbox-input-full" />
      </div>
      <div class="section sandbox-section-spacing">
        <button id="btnProcess" type="button" class="btn btn-success">Process</button>
      </div>
      <div class="section result sandbox-section-spacing">
        <div id="loadingOverlayProcess" class="loading-overlay"><img src="https://discuss.wxpython.org/uploads/default/original/2X/6/6d0ec30d8b8f77ab999f765edd8866e8a97d59a3.gif" /></div>
        <textarea id="textResultProcess" name="textResultProcess" class="sandbox-textarea"></textarea>
      </div>
    </div>
  </div>

  <script src="codedoc.js"></script>
  <script>
    insertPageHeader();

    // Definition of the samples that will be returned when you click on the 'Get a Sample URL' button.
    const URLS = {
      'Esri Dynamic': {
        type: 'esriDynamic',
        url: 'https://maps-cartes.ec.gc.ca/arcgis/rest/services/CESI/MapServer',
        layerIds: [2,3]
      },
      'Esri Image - USA Cities (Actually an Esri Dynamic service)': {
        type: 'esriImage',
        url: 'https://sampleserver6.arcgisonline.com/ArcGIS/rest/services/USA/MapServer',
        layerIds: ['0']
      },
      'Esri Image - Annual Crop': {
        type: 'esriImage',
        url: 'https://www5.agr.gc.ca/atlas/rest/services/imageservices/annual_crop_inventory_2022/ImageServer',
        layerIds: ['annual_crop_inventory_2022']
      },
      'Image Static - Napl Ring Of Fire (no process)': {
        type: 'imageStatic',
        url: 'https://datacube-prod-data-public.s3.ca-central-1.amazonaws.com/store/imagery/aerial/napl/napl-ring-of-fire',
        layerIds: ['napl-ring-of-fire-1954-08-07-60k-thumbnail.png']
      },
      'WMS': {
        type: 'ogcWms',
        url: 'https://geo.weather.gc.ca/geomet',
        layerIds: ['RADAR_1KM_RSNO']
      },
      'WMS - CER Assessments': {
        type: 'ogcWms',
        url: 'https://maps-cartes.services.geo.ca/server_serveur/services/NRCan/CER_Assessments_EN/MapServer/WMSServer',
        layerIds: [0]
      },
      'Vector Tiles - CBMT_CBCT_3978_V_OSM': {
        type: 'vectorTiles',
        url: 'https://tiles.arcgis.com/tiles/HsjBaDykC1mjhXz9/arcgis/rest/services/CBMT_CBCT_3978_V_OSM/VectorTileServer',
        layerIds: ['CBMT_CBCT_3978_V_OSM']
      },
      'Vector Tiles - CBMT3978_v11 with xyz': {
        type: 'vectorTiles',
        url: 'https://tiles.arcgis.com/tiles/HsjBaDykC1mjhXz9/arcgis/rest/services/CBMT3978_v11/VectorTileServer/tile/{z}/{y}/{x}.pbf'
      },
      'XYZ Tiles - World_Topo_Map': {
        type: 'xyzTiles',
        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer',
        layerIds: ['0']
      },
      'XYZ Tiles - World_Topo_Map with xyz': {
        type: 'xyzTiles',
        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}'
      },
      'CSV': {
        type: 'CSV',
        url: 'https://canadian-geospatial-platform.github.io/geoview/public/datasets/csv-files/Station_List_Minus_HQ-MELCC.csv',
        isVector: true
      },
      'CSV - WaterMedia': {
        type: 'CSV',
        url: 'https://canadian-geospatial-platform.github.io/geoview/public/datasets/csv-files',
        layerIds: ['NPRI-INRP_WaterEau_MediaGroupMilieu_2022'],
        isVector: true
      },
      'Esri Feature - Flood Map': {
        type: 'esriFeature',
        url: 'https://maps-cartes.services.geo.ca/server_serveur/rest/services/NRCan/canada_flood_map_inventory_en/MapServer',
        layerIds: [0]
      },
      'Esri Feature - Toronto': {
        type: 'esriFeature',
        url: 'https://services.arcgis.com/V6ZHFr6zdgNZuVG0/ArcGIS/rest/services/Toronto_Neighbourhoods/FeatureServer',
        layerIds: [0]
      },
      'GeoJSON - Polygons': {
        type: 'GeoJSON',
        url: 'https://canadian-geospatial-platform.github.io/geoview/public/datasets/geojson',
        layerIds: ['polygons.json'],
        isVector: true
      },
      'GeoJSON - .meta file': {
        type: 'GeoJSON',
        url: 'https://canadian-geospatial-platform.github.io/geoview/public/datasets/geojson/metadata.meta',
        layerIds: ['polygons.json'],
        isVector: true
      },
      'OGC Feature - Lakes': {
        type: 'ogcFeature',
        url: 'https://b6ryuvakk5.execute-api.us-east-1.amazonaws.com/dev',
        layerIds: ['lakes'],
        isVector: true
      },
      'WFS - Current Conditions': {
        type: 'ogcWfs',
        url: 'https://geo.weather.gc.ca/geomet',
        layerIds: ['ec-msc:CURRENT_CONDITIONS']
      },
      'WFS - States': {
        type: 'ogcWfs',
        url: 'https://ahocevar.com/geoserver/wfs?REQUEST=GetCapabilities&VERSION=2.0.0&SERVICE=WFS',
        layerIds: ['usa:states']
      },
      'WKB - Rivers': {
        type: 'WKB',
        url: 'https://some-wkb-url/rivers',
        layerIds: ['rivers']
      },
      'Geocore - Airborne': {
        type: 'geoCore',
        url: '21b821cf-0f1c-40ee-8925-eab12d357668',
        layerIds: ['0']
      },
      'Shapefile - single': {
        type: 'shapefile',
        url: "./datasets/shapefiles/PLAN_CrownHarvestPlans_SHP_UT83.zip",
        layerIds: ['PLAN_CrownHarvestPlans_UT83']
      },
      'Shapefile - 2 layer ids': {
        type: 'shapefile',
        url: "./datasets/shapefiles/PLAN_CrownHarvestPlans_SHP_UT83.zip",
        layerIds: ['PLAN_CrownHarvestPlans_UT83', 'PLAN_CrownHarvestPlansArchived_UT83']
      },
      'GeoPackage - Rivers': {
        type: 'GeoPackage',
        url: 'https://canadian-geospatial-platform.github.io/geoview/public/datasets/geopackages/rivers.gpkg',
        layerIds: ['rivers']
      }
    };

    const selectLayerTypes = document.getElementById('urls');
    const selectLang = document.getElementById('language');
    const txtUrl = document.getElementById('txtUrl');
    const sectionLayerId = document.getElementById('section-layer-id');
    const txtLayerId = document.getElementById("txtLayerId");
    const txtError = document.getElementById('txtError');
    const txtLayers = document.getElementById('txtLayers');
    const btnInitialize = document.getElementById('btnInitialize');
    const btnProcess = document.getElementById('btnProcess');
    const loadingOverlayInit = document.getElementById('loadingOverlayInit');
    const loadingOverlayProcess = document.getElementById('loadingOverlayProcess');

    function updateUI(valueInput) {
      // Update the url txt
      const value = JSON.parse(valueInput);

      // Hide the layer id option
      sectionLayerId.style.display = "none";
      if (value.type === 'esriFeature') {
        // Show it
        sectionLayerId.style.display = "block";
        // Load the layer id there, by default, as an Esri Feature layer url needs a layer id
        txtLayerId.value = value.layerIds[0];
      }
    }

    /* Updates the url input based on the user selection in the selector */
    function updateUrlInput(valueInput) {
      // Update the url txt
      const value = JSON.parse(valueInput);
      txtUrl.value = value.url;

      // If any layer ids
      txtLayers.value = '';
      if (value.layerIds) {
        txtLayers.value = value.layerIds.join(', ');
      }

      // If layer is vector type
      txtProcessInfoVector.style.display = "none";
      if (value.isVector) {
        txtProcessInfoVector.style.display = "block";
      }
    }

    function loadUI() {
      // Populate the <select> with options
      Object.entries(URLS).forEach(([label, value]) => {
        const option = document.createElement('option');
        option.value = JSON.stringify(value);
        option.textContent = label;
        selectLayerTypes.appendChild(option);
      });

      // Update url input based on the selected option
      updateUrlInput(selectLayerTypes.value);
    }

    function cleanUIInit() {
      editorResultInit.setValue('');
      txtError.innerHTML = '';
    }

    function cleanUIProcess() {
      editorResultProcess.setValue('');
      txtError.innerHTML = '';
    }

    function showHideLoadingInit(show) {
      loadingOverlayInit.style.display = "none";
      if (show) loadingOverlayInit.style.display = "block";
    }

    function showHideLoadingProcess(show) {
      loadingOverlayProcess.style.display = "none";
      if (show) loadingOverlayProcess.style.display = "block";
    }

    /* Initializes the Layer and fills the text area with the result */
    async function initializeLayer(layerType, layerUrl, language) {
      try {
        // Clear
        cleanUIInit();
        showHideLoadingInit(true);

        // Call the ConfigApi to get the Layer Tree
        const initializedLayerConfig = await cgpv.api.config.createInitConfigFromType(
          layerType,
          'geoviewLayerId',
          'geoviewLayerName',
          layerUrl.trim(),
          language
        );

        // Output instanciation result
        editorResultInit.setValue(cgpv.api.config.serializeGeoviewLayerConfig(initializedLayerConfig));
      } finally {
        // Hide loading
        showHideLoadingInit(false);
      }
    }

    async function processLayer(layerType, layerUrl, language, layerIds) {
      try {
        // Clear
        cleanUIProcess();
        showHideLoadingProcess(true);

        // If a geocore or shapefile
        if (layerType === 'geoCore' || layerType === 'shapefile' || layerType === 'GeoPackage') {
          // It's a geocore or shapefile, first initialize it and get the layer tree
          const initializedLayerConfig = await cgpv.api.config.createInitConfigFromType(
            layerType,
            'geoviewLayerId',
            'geoviewLayerName',
            layerUrl.trim(),
            language
          );

          // Tweak the parameters
          layerType = initializedLayerConfig.geoviewLayerType;
          layerUrl = initializedLayerConfig.metadataAccessPath;
        }

        // Call the ConfigApi to process the layers into actual layer config classes
        const configClasses = await cgpv.api.config.processLayerFromType(
          layerType,
          'geoviewLayerId',
          'geoviewLayerName',
          layerUrl.trim(),
          layerIds
        );

        // Output instanciation result
        editorResultProcess.setValue(cgpv.api.config.serializeConfigClasses(configClasses));
      } finally {
        // Hide loading
        showHideLoadingProcess(false);
      }
    }

    // Transform the text area into a code text area using CodeMirror
    const editorResultInit = CodeMirror.fromTextArea(document.getElementById('textResultInit'), {
        lineNumbers: true,
        mode: 'text/x-perl',
        theme: 'liquibyte',
    });

    // Transform the text area into a code text area using CodeMirror
    const editorResultProcess = CodeMirror.fromTextArea(document.getElementById('textResultProcess'), {
        lineNumbers: true,
        mode: 'text/x-perl',
        theme: 'liquibyte',
    });

    // Load the UI
    loadUI();

    // Handles a change of the url selection
    selectLayerTypes.addEventListener('change', function (e) {
      // Update UI based on the selected option
      updateUI(e.target.value);

      // Update url input based on the selected option
      updateUrlInput(e.target.value);
    });

    // Handles a click on the initialize button
    btnInitialize.addEventListener('click', async function (e) {
      try {
        // Get the selected value
        const value = JSON.parse(selectLayerTypes.value);

        // If an EsriFeature, suffix the url with the layer id
        let url = txtUrl.value;
        if (value.type === 'esriFeature') {
          url = cleanURL(url);
          url = url + '/' + txtLayerId.value;
        }

        // Go
        await initializeLayer(value.type, url, selectLang.value);
      } catch (error) {
        // Log
        cgpv.logger.logError(error);
        txtError.innerHTML = error.message;
      }
    });

    // Handles a click on the process button
    btnProcess.addEventListener('click', async function (e) {
      try {
        // Get the selected value
        const value = JSON.parse(selectLayerTypes.value);

        // Get the layer ids
        let layerIds = [];
        if (txtLayers.value.trim()) {
          layerIds = txtLayers.value.split(',').map((lyrId) => lyrId.trim());
        }

        // Go
        await processLayer(value.type, txtUrl.value, selectLang.value, layerIds);
      } catch (error) {
        // Log
        cgpv.logger.logError(error);
        txtError.innerHTML = error.message;
      }
    });
  </script>
</body>
</html>
